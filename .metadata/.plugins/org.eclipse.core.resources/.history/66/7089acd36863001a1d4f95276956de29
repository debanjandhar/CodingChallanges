import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 * @author debanjandhar
 * 
 *         Question :
 *         https://www.hackerrank.com/challenges/the-quickest-way-up/problem
 * 
 */
public class SnakesAndLadders {

	// Complete the quickestWayUp function below.
	private static int quickestWayUp(int[][] ladders, int[][] snakes) {
		Queue<Cell> cellQueue = new LinkedList<Cell>();

		cellQueue.add(new Cell(1));

		return 1;
	}

	private int quickestWayUp(int[][] ladders, int[][] snakes, Queue<Cell> queue) {
		if (queue.peek() == null) {
			return -1;
		}

		Cell currentCell = queue.remove();

		// Check if we have any cell with ladder before we role 6
		int nextLadderCellId = getNextLadderCell(currentCell, ladders);
		if (nextLadderCellId != -1) {
			// Add ladder cell to queue
			queue.add(new Cell(nextLadderCellId, currentCell.getLength()+1));
		}

		// We will start with maximum dice roll and keep reducing by 1, if the next cell
		// is not valid.
		int diceRoll = 6;
		while (diceRoll == 0) {
			int nextCellId = currentCell.getCellId() + diceRoll;
			
			if (nextLadderCellId != nextCellId && isValidCell(nextCellId, snakes)) {
				queue.add(new Cell(currentCell.getCellId()+diceRoll, currentCell.getLength()+1));
				break;
			}
			diceRoll--;
		}

	}

	// Checks if next cell is does not contain a snake
	private boolean isValidCell(int cellId, int[][] snakes) {
		int numSnakes = snakes.length;
		for (int i = 0; i < numSnakes; i++) {

			// Check if this cell is start point of a snake.
			if (cellId == snakes[i][0]) {
				return false;
			}
		}
		return true;
	}

	// This function returns destination cell id if ladder is present, else returns
	// -1
	private int getNextLadderCell(Cell currentCell, int[][] ladders) {
		return -1;
	}

	private static final Scanner scanner = new Scanner(System.in);

	public static void main(String[] args) throws IOException {
		BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

		int t = scanner.nextInt();
		scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

		for (int tItr = 0; tItr < t; tItr++) {
			int n = scanner.nextInt();
			scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

			int[][] ladders = new int[n][2];

			for (int i = 0; i < n; i++) {
				String[] laddersRowItems = scanner.nextLine().split(" ");
				scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

				for (int j = 0; j < 2; j++) {
					int laddersItem = Integer.parseInt(laddersRowItems[j]);
					ladders[i][j] = laddersItem;
				}
			}

			int m = scanner.nextInt();
			scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

			int[][] snakes = new int[m][2];

			for (int i = 0; i < m; i++) {
				String[] snakesRowItems = scanner.nextLine().split(" ");
				scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

				for (int j = 0; j < 2; j++) {
					int snakesItem = Integer.parseInt(snakesRowItems[j]);
					snakes[i][j] = snakesItem;
				}
			}

			int result = quickestWayUp(ladders, snakes);

			bufferedWriter.write(String.valueOf(result));
			bufferedWriter.newLine();
		}

		bufferedWriter.close();

		scanner.close();
	}
}

class Cell {
	int cellId;
	int length;

	public Cell(int cellId, int length) {
		this.cellId = cellId;
		this.length = length;
	}

	public Cell(int cellId) {
		this.cellId = cellId;
		this.length = 0;
	}

	public int getCellId() {
		return cellId;
	}

	public void setCellId(int cellId) {
		this.cellId = cellId;
	}

	public int getLength() {
		return length;
	}

	public void setLength(int length) {
		this.length = length;
	}

}
